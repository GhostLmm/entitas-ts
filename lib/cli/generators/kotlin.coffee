#!/usr/bin/env coffee
###
 * Entitas code generation
 *
 * Generate Kotlin stubs for
 * use with libGDX
 *
 * Demo: 
 * https://github.com/darkoverlordofdata/Bosco.ECS
 * https://github.com/darkoverlordofdata/shmupwarz-unity
 *
###
fs = require('fs')
path = require('path')
mkdirp = require('mkdirp')
config = require("#{process.cwd()}/entitas.json")

getType = (arg) ->
  switch arg
    when 'number'   then 'Float'
    when 'string'   then 'String'
    when 'boolean'  then 'Boolean'
    when 'any'      then 'Any'
    else arg

getDefault = (arg) ->
  switch arg
    when 'boolean'  then 'false'
    when 'string'   then '""'
    when 'number'   then '0f'
    when 'any'      then 'null'
    else arg
    

params = (args) ->
  s = []
  for arg in args
    name = arg.split(':')[0]
    type = getType(arg.split(':')[1])
    s.push "#{name}"
    
  s.join(', ') 
  

module.exports =
#
# generate entity extensions
#
# @return none
#
  run: (flags...) ->

    sb = []
    s0 = []
    ext = {}
    sys = {}
    s1 = ext['Entity'] = []
    s2 = ext['Matcher'] = []
    s3 = ext['World'] = []
    
    sb.push "package #{config.namespace}"
    sb.push "/**"
    sb.push " * Entitas Global Functions for #{config.namespace}"
    sb.push " *"
    sb.push " * do not edit this file"
    sb.push " */"
    
    s0.push "namespace #{config.namespace}"
    s0.push "/**"
    s0.push " * Entitas Generated Components for #{config.namespace}"
    s0.push " *"
    s0.push " * do not edit this file"
    s0.push " */"
    s0.push ""
    s0.push "import com.darkoverlordofdata.entitas"
    s0.push "import java.util.*"
    s0.push ""
    
    s1.push "namespace #{config.namespace}"
    s1.push "/**"
    s1.push " * Entitas Generated Entity Extensions for #{config.namespace}"
    s1.push " *"
    s1.push " * do not edit this file"
    s1.push " */"
    s1.push ""
    s1.push "import com.darkoverlordofdata.entitas"
    s1.push "import java.util.*"
    s1.push ""
    
    s2.push "namespace #{config.namespace}"
    s2.push "/**"
    s2.push " * Entitas Generated Matcher Extensions for #{config.namespace}"
    s2.push " *"
    s2.push " * do not edit this file"
    s2.push " */"
    s2.push ""
    s2.push "import com.darkoverlordofdata.entitas"
    s2.push "import java.util.*"
    s2.push ""
    
    s3.push "namespace #{config.namespace}"
    s3.push "/**"
    s3.push " * Entitas Generated World Extensions for #{config.namespace}"
    s3.push " *"
    s3.push " * do not edit this file"
    s3.push " */"
    s3.push ""
    s3.push "import com.darkoverlordofdata.entitas"
    s3.push "import java.util.*"
    s3.push ""
    

    ###
     * Components Type Definitions
    ###
    for Name, properties of config.components
      name = Name[0].toLowerCase()+Name[1...]
      s0.push ""
      s0.push "    [<AllowNullLiteral>]"
      s0.push "    type #{Name}Component() ="
      s0.push "        inherit Component()"
      if properties is false 
        s0.push "        member val active = false with get, set"
      else
        for p in properties
          name = p.split(':')[0]
          value = getDefault(p.split(':')[1])
          s0.push "        member val #{name} = #{value} with get, set"
      
    ###
     * Systems Type Definitions
    ###
    for Name, interfaces of config.systems
      name = Name[0].toLowerCase()+Name[1...]
      sy = sys[Name] = []
      sy.push "namespace #{config.namespace}"
      sy.push ""
      sy.push "/**"
      sy.push " * Entitas Generated Systems for #{config.namespace}"
      sy.push " *"
      sy.push " */"
      sy.push ""
      sy.push "open Entitas"
      sy.push "open System"
      sy.push "open System.Collections.Generic"
      sy.push ""
      sy.push "type #{Name}(world:World) ="
      
      found = false
      for iface in interfaces

        if 'IExecuteSystem' is iface
          sy.push "    interface IExecuteSystem with"
          sy.push "        member this.Execute() ="
          sy.push "            ()"
          found = true
          
        if 'IInitializeSystem' is iface
          sy.push "    interface IInitializeSystem with"
          sy.push "        member this.Initialize() ="
          sy.push "            ()"
          found = true

      sy.push "    class end" unless found 
    sy.push ""
               
    ###
     * Components List
    ###
    s0.push ""
    s0.push "    type Component with "
    s1.push "    type Entity with"     
    s1.push ""     
    s2.push "    type Matcher with"
    s3.push "    type World with"
    s3.push ""     
    
    kc = 0
    for Name, properties of config.components
      name = Name[0].toLowerCase()+Name[1...]
      s0.push "        static member #{Name} with get() = #{++kc}"    
    s0.push "        static member TotalComponents  with get() = #{++kc}"    
    s0.push ""
  
    
    for Name, properties of config.components
      name = Name[0].toLowerCase()+Name[1...];
      
      s1.push "        (** Entity: #{Name} methods*)"
      
      switch properties
        when false
          s1.push ""
          s1.push "        static member #{name}Component= new #{Name}Component()"
          s1.push ""
          s1.push "        member this.is#{Name}"
          s1.push "            with get() ="
          s1.push "                this.HasComponent(Component.#{Name})"
          s1.push "            and  set(value) ="
          s1.push "                if value <> this.is#{Name} then"
          s1.push "                    this.AddComponent(Component.#{Name}, Entity.#{name}Component) |> ignore"
          s1.push "                else"
          s1.push "                    this.RemoveComponent(Component.#{Name}) |> ignore"
          s1.push ""
          s1.push "        member this.Is#{Name}(value) ="
          s1.push "            this.is#{Name} <- value"
          s1.push "            this"
          s1.push ""
          s2.push "        static member #{Name}"
          s2.push "            with get() = "
          s2.push "                Matcher.AllOf(Component.#{Name}) "
          s2.push ""
          
        else
          s1.push ""
          s1.push "        member this.#{name}"
          s1.push "            with get() = this.GetComponent(Component.#{Name}):?>#{Name}Component"
          s1.push ""
          s1.push "        member this.has#{Name}"
          s1.push "            with get() = this.HasComponent(Component.#{Name})"
          s1.push ""
          s1.push "        member this._#{name}ComponentPool"
          s1.push "             with get() = new Stack<#{Name}Component>()"
          s1.push ""
          s1.push "        member this.Clear#{Name}ComponentPool() ="
          s1.push "            this._#{name}ComponentPool.Clear()"
          s1.push ""
          s1.push "        member this.Add#{Name}(#{params(properties)}) ="
          s1.push "            let mutable c = "
          s1.push "              match this._#{name}ComponentPool.Count with"
          s1.push "              | 0 -> new #{Name}Component()"
          s1.push "              | _ -> this._#{name}ComponentPool.Pop()"
          for p in properties
            s1.push "            c.#{p.split(':')[0]} <- #{p.split(':')[0]};"
          s1.push "            this.AddComponent(Component.#{Name}, c)"
          s1.push ""
          s1.push "        member this.Replace#{Name}(#{params(properties)}) ="
          s1.push "            let previousComponent = if this.has#{Name} then this.#{name} else null"
          s1.push "            let mutable c = "
          s1.push "              match this._#{name}ComponentPool.Count with"
          s1.push "              | 0 -> new #{Name}Component()"
          s1.push "              | _ -> this._#{name}ComponentPool.Pop()"
          for p in properties
            s1.push "            c.#{p.split(':')[0]} <- #{p.split(':')[0]};"
          s1.push "            this.ReplaceComponent(Component.#{Name}, c) |> ignore"
          s1.push "            if not(isNull(previousComponent)) then"
          s1.push "                this._#{name}ComponentPool.Push(previousComponent)"
          s1.push "            this"
          s1.push ""
          s1.push "        member this.Remove#{Name}() ="
          s1.push "            let c = this.#{name}"
          s1.push "            this.RemoveComponent(Component.#{Name}) |> ignore"
          s1.push "            this._#{name}ComponentPool.Push(c)"
          s1.push ""
          s2.push "        static member #{Name}"
          s2.push "            with get() = "
          s2.push "                Matcher.AllOf(Component.#{Name}) "
          s2.push ""
          
    ###
     * Pooled Entities
    ###
    for Name, pooled of config.entities
        
      s3.push "        (** World: #{Name} methods*)"
        
      if pooled
        name = Name[0].toLowerCase()+Name[1...];
        properties = config.components[Name]
        if config.components[Name] is false
          s3.push ""
          s3.push "        member this.#{name}Entity"
          s3.push "            with get() = this.GetGroup(Matcher.#{Name}).GetSingleEntity()"
          s3.push ""
          s3.push "        member this.is#{Name}"
          s3.push "            with get() ="
          s3.push "                this.#{name}Entity.NotNull"
          s3.push "            and  set(value) ="
          s3.push "                let entity = this.#{name}Entity"
          s3.push "                if value <> entity.NotNull then"
          s3.push "                    if value then"
          s3.push "                        this.CreateEntity(\"#{Name}\").is#{Name} <- true"
          s3.push "                    else"
          s3.push "                        this.DestroyEntity(entity)"
          s3.push ""
        else
          s3.push ""
          s3.push "        member this.#{name}Entity"
          s3.push "            with get() = this.GetGroup(Matcher.#{Name}).GetSingleEntity()"
          s3.push ""
          s3.push "        member this.#{name}"
          s3.push "            with get() = this.#{name}Entity.#{name}"
          s3.push ""
          s3.push "        member this.has#{Name}"
          s3.push "            with get() = this.#{name}Entity.NotNull"
          s3.push ""
          s3.push "        member this.Set#{Name}(newValue) ="
          s3.push "            if this.has#{Name} then"
          s3.push "                failwith \"Single Entity Exception: #{Name}\""
          s3.push "            let entity = this.CreateEntity(\"#{Name}\")"
          s3.push "            entity.Add#{Name}(newValue) |> ignore"
          s3.push "            entity"
          s3.push ""
          s3.push "        member this.Replace#{Name}(newValue) ="
          s3.push "            let entity = this.#{name}Entity"
          s3.push "            if entity.IsNull then"
          s3.push "                entity = this.Set#{Name}(newValue) |> ignore"
          s3.push "            else"
          s3.push "                entity.Replace#{Name}(newValue) |> ignore"
          s3.push "            entity"
          s3.push ""
          s3.push "        member this.Remove#{Name}() ="
          s3.push "            this.DestroyEntity(this.#{name}Entity)"
          s3.push ""
          
               
    #
    # ./<Namespace>.fs - Component declarations
    # ./Systems/*.fs - System Classes
    # ./Extensions/GlobalExtensions.fs
    # ./Extensions/EntityExtensions.fs
    # ./Extensions/MatcherExtensions.fs
    # ./Extensions/WorldExtensions.fs
    #               
    mkdirp.sync path.dirname(path.join(process.cwd(), config.output.fsharp))
    mkdirp.sync path.join(process.cwd(), config.output.fsharp, "Systems")
    mkdirp.sync path.join(process.cwd(), config.output.fsharp, "Extensions")

    fs.writeFileSync(path.join(process.cwd(), config.output.fsharp, 
      "Extensions/GlobalExtensions.fs"), sb.join('\n'))
    
    # Components - overwrite
    fs.writeFileSync(path.join(process.cwd(), config.output.fsharp, 
      "Extensions/ComponentExtensions.fs"), s0.join('\n'))
    
    # Extensions - overwrite
    for Name, ex of ext
      fs.writeFileSync(path.join(process.cwd(), config.output.fsharp, 
        "Extensions/#{Name}Extensions.fs"), ex.join('\n'))

    # Systems - Do Not overwrite
    for Name, sy of sys
      fileName = path.join(process.cwd(), config.output.fsharp, "Systems/#{Name}.fs")
      fs.writeFileSync(fileName, sy.join('\n')) unless fs.existsSync(fileName)

      