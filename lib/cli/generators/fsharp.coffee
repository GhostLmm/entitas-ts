#!/usr/bin/env coffee
###
 * Entitas code generation
 *
 * Generate FSharp stubs for
 * use by ecs-fsharp in Unity
 *
###
fs = require('fs')
path = require('path')
mkdirp = require('mkdirp')
config = require("#{process.cwd()}/entitas.json")

getType = (arg) ->
  switch arg
    when 'number'   then 'float'
    when 'string'   then 'string'
    when 'boolean'  then 'bool'
    when 'any'      then 'Object'
    else arg

getDefault = (arg) ->
  switch arg
    when 'boolean'  then 'false'
    when 'string'   then '""'
    when 'number'   then '0.0f'
    when 'any'      then 'null'
    else arg
    

params = (args) ->
  sb = []
  for arg in args
    name = arg.split(':')[0]
    type = getType(arg.split(':')[1])
    sb.push "#{name}"
    
  sb.join(', ') 
  

module.exports =
#
# generate entity extensions
#
# @return none
#
  run: (flags...) ->

    sb = []
    ex = []
    sys = {}
    
    sb.push "namespace #{config.namespace}"
    sb.push ""
    sb.push "(**"
    sb.push " * Entitas Generated Components for #{config.namespace}"
    sb.push " *"
    sb.push " * do not edit this file"
    sb.push " *)"
    sb.push ""
    sb.push "open Entitas"
    sb.push "open System"
    sb.push "open System.Collections.Generic"
    
    ex.push "module #{config.namespace}Extensions"
    ex.push ""
    ex.push "(**"
    ex.push " * Entitas Generated Extensions for #{config.namespace}"
    ex.push " *"
    ex.push " * do not edit this file"
    ex.push " *)"
    ex.push ""
    ex.push "open Entitas"
    ex.push "open #{config.namespace}"
    ex.push "open System"
    ex.push "open System.Collections.Generic"

    ###
     * Components Type Definitions
    ###
    for Name, properties of config.components
      name = Name[0].toLowerCase()+Name[1...]
      sb.push ""
      sb.push "[<AllowNullLiteral>]"
      sb.push "type #{Name}Component() ="
      sb.push "    inherit Component()"
      if properties is false 
        sb.push "    member val active = false with get, set"
      else
        for p in properties
          name = p.split(':')[0]
          value = getDefault(p.split(':')[1])
          sb.push "    member val #{name} = #{value} with get, set"
      
    ###
     * Systems Type Definitions
    ###
    for Name, interfaces of config.systems
      name = Name[0].toLowerCase()+Name[1...]
      sy = sys[Name] = []
      sy.push "namespace #{config.namespace}"
      sy.push ""
      sy.push "(**"
      sy.push " * Entitas Generated Systems for #{config.namespace}"
      sy.push " *"
      sy.push " *)"
      sy.push ""
      sy.push "open Entitas"
      sy.push "open System"
      sy.push "open System.Collections.Generic"
      sy.push ""
      sy.push "type #{Name}(world) ="
      
      found = false
      for iface in interfaces

        if 'IExecuteSystem' is iface
          sy.push "    interface IExecuteSystem with"
          sy.push "        member this.Execute() ="
          sy.push "            ()"
          found = true
          
        if 'IInitializeSystem' is iface
          sy.push "    interface IInitializeSystem with"
          sy.push "        member this.Initialize() ="
          sy.push "            ()"
          found = true

      sy.push "    class end" unless found 
    sy.push ""
               
    ###
     * Entity Extensions
    ###
    ex.push ""
    ###
     * Components List
    ###
    ex.push "let isNull x = match x with null -> true | _ -> false"
    ex.push "let notNull x = match x with null -> false | _ -> true"
    ex.push ""
    ex.push "type Component with "
    kc = 0
    for Name, properties of config.components
      name = Name[0].toLowerCase()+Name[1...]
      ex.push "    static member #{Name} with get() = #{++kc}"    
    ex.push "    static member TotalComponents  with get() = #{++kc}"    
    ex.push ""
    ex.push "type ComponentId = "
    kc = 0
    for Name, properties of config.components
      name = Name[0].toLowerCase()+Name[1...]
      ex.push "  | #{Name} = #{++kc}"    
    ex.push "  | TotalComponents = #{++kc}"    
    ex.push ""
  
    for Name, properties of config.components
      name = Name[0].toLowerCase()+Name[1...];
      switch properties
        when false
          ex.push "type Entity with"     
          ex.push ""
          ex.push "    static member #{name}Component= new #{Name}Component()"
          ex.push ""
          ex.push "    member this.is#{Name}"
          ex.push "        with get() ="
          ex.push "            this.HasComponent(Component.#{Name})"
          ex.push "        and  set(value) ="
          ex.push "            if value <> this.is#{Name} then"
          ex.push "                this.AddComponent(Component.#{Name}, Entity.#{name}Component) |> ignore"
          ex.push "            else"
          ex.push "                this.RemoveComponent(Component.#{Name}) |> ignore"
          ex.push ""
          ex.push "    member this.Is#{Name}(value) ="
          ex.push "        this.is#{Name} <- value"
          ex.push "        this"
          ex.push ""
          ex.push "type Matcher with "
          ex.push "    static member #{Name} with get() = Matcher.AllOf(Component.#{Name}) "
          ex.push ""
          
        else
          ex.push "type Entity with"
          ex.push "    member this.#{name}"
          ex.push "        with get() = this.GetComponent(Component.#{Name}):?>#{Name}Component"
          ex.push ""
          ex.push "    member this.has#{Name}"
          ex.push "        with get() = this.HasComponent(Component.#{Name})"
          ex.push ""
          ex.push "    member this._#{name}ComponentPool"
          ex.push "         with get() = new Stack<#{Name}Component>()"
          ex.push ""
          ex.push "    member this.Clear#{Name}ComponentPool() ="
          ex.push "        this._#{name}ComponentPool.Clear()"
          ex.push ""
          ex.push "    member this.Add#{Name}(#{params(properties)}) ="
          ex.push "        let mutable c = "
          ex.push "          match this._#{name}ComponentPool.Count with"
          ex.push "          | 0 -> new #{Name}Component()"
          ex.push "          | _ -> this._#{name}ComponentPool.Pop()"
          for p in properties
            ex.push "        c.#{p.split(':')[0]} <- #{p.split(':')[0]};"
          ex.push "        this.AddComponent(Component.#{Name}, c)"
          ex.push ""
          ex.push "    member this.Replace#{Name}(#{params(properties)}) ="
          ex.push "        let previousComponent = if this.has#{Name} then this.#{name} else null"
          ex.push "        let mutable c = "
          ex.push "          match this._#{name}ComponentPool.Count with"
          ex.push "          | 0 -> new #{Name}Component()"
          ex.push "          | _ -> this._#{name}ComponentPool.Pop()"
          for p in properties
            ex.push "        c.#{p.split(':')[0]} <- #{p.split(':')[0]};"
          ex.push "        this.ReplaceComponent(Component.#{Name}, c) |> ignore"
          ex.push "        if not(isNull(previousComponent)) then"
          ex.push "            this._#{name}ComponentPool.Push(previousComponent)"
          ex.push "        this"
          ex.push ""
          ex.push "    member this.Remove#{Name}() ="
          ex.push "        let c = this.#{name}"
          ex.push "        this.RemoveComponent(Component.#{Name}) |> ignore"
          ex.push "        this._#{name}ComponentPool.Push(c)"
          ex.push ""
          ex.push "type Matcher with "
          ex.push "    static member #{Name} with get() = Matcher.AllOf(Component.#{Name}) "
          ex.push ""
          
    ###
     * Pooled Entities
    ###
    ex.push "type World with"
    for Name, pooled of config.entities
      if pooled
        name = Name[0].toLowerCase()+Name[1...];
        properties = config.components[Name]
        if config.components[Name] is false
          ex.push ""
          ex.push "    member this.#{name}Entity"
          ex.push "        with get() = this.GetGroup(Matcher.#{Name}).GetSingleEntity()"
          ex.push ""
          ex.push "    member this.is#{Name}"
          ex.push "        with get() ="
          ex.push "            notNull(this.#{name}Entity)"
          ex.push "        and  set(value) ="
          ex.push "            let entity = this.#{name}Entity"
          ex.push "            if value <> notNull(entity) then"
          ex.push "                if value then"
          ex.push "                    this.CreateEntity().is#{Name} <- true"
          ex.push "                else"
          ex.push "                    this.DestroyEntity(entity)"
          ex.push ""
        else
          ex.push ""
          ex.push "    member this.#{name}Entity"
          ex.push "        with get() = this.GetGroup(Matcher.#{Name}).GetSingleEntity()"
          ex.push ""
          ex.push "    member this.#{name}"
          ex.push "        with get() = this.#{name}Entity.#{name}"
          ex.push ""
          ex.push "    member this.has#{Name}"
          ex.push "        with get() = notNull(this.#{name}Entity)"
          ex.push ""
          ex.push "    member this.Set#{Name}(newValue) ="
          ex.push "        if this.has#{Name} then"
          ex.push "            failwith \"Single Entity Exception: #{Name}\""
          ex.push "        let entity = this.CreateEntity()"
          ex.push "        entity.Add#{Name}(newValue) |> ignore"
          ex.push "        entity"
          ex.push ""
          ex.push "    member this.Replace#{Name}(newValue) ="
          ex.push "        let entity = this.#{name}Entity"
          ex.push "        if isNull(entity) then"
          ex.push "            entity = this.Set#{Name}(newValue) |> ignore"
          ex.push "        else"
          ex.push "            entity.Replace#{Name}(newValue) |> ignore"
          ex.push "        entity"
          ex.push ""
          ex.push "    member this.Remove#{Name}() ="
          ex.push "        this.DestroyEntity(this.#{name}Entity)"
          ex.push ""
          
               
    mkdirp.sync path.dirname(path.join(process.cwd(), config.output.fsharp))
    mkdirp.sync path.join(process.cwd(), config.output.fsharp, "Systems")
    
    fs.writeFileSync(path.join(process.cwd(), config.output.fsharp, "#{config.namespace}.fs"), sb.join('\n'))
    fs.writeFileSync(path.join(process.cwd(), config.output.fsharp, "#{config.namespace}Extensions.fs"), ex.join('\n'))

    for Name, sy of sys
      fs.writeFileSync(path.join(process.cwd(), config.output.fsharp, "Systems/#{Name}.fs"), sy.join('\n'))
      